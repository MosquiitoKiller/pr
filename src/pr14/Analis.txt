Линейный поиск имеет сложность O(n)
Док-во:
                 Действие                 |кол-во |время на операцию
------------------------------------------|-------|------------------
for (int i = 0; i < getters.length; i++)  |   n   |     C1
    if(getters[i].equals(g))              |   n   |     C2
return                                    |   1   |     C3

O(n)=C1*n+C2*n+C3=(C1+C2)*n+C3=C*n+C3
O(C*n+C3) = O(n)
Линейный рекурсивный поиск при рассмотрении развертывается в линейный, а значит имеет аналогичную сложность т.е. O(n)
=============================================
Бинарный поиск имеет сложность O(log n), где log - двоичный логарифм
Док-во:
                 Действие                 |кол-во |время на операцию
------------------------------------------|-------|------------------
int mid,min=0,max=getters.length          |   1   |     C1
mid=(max-min)/2+min;                      | log n |     C2              *
if((mid==min)||(mid==max))                | log n |     C3              *
if(...) min=mid; else max=mid;            | log n |     C4              *
                                          |       |
if(...) return mid;                       |   1   |     C5
else return Integer.MIN_VALUE;            |   1   |     C5

Док-во *:
На каждой итерации массив делится пополам. Допустим, длина массива на первой итерации равна n.
Допустим, итерация в двоичном поиске заканчивается после k итераций.
Длина массива на первой итерации: n=n/2^(0)
Длина массива на второй итерации: n/2=n/2^(1)
Длина массива на третьей итерации: n/4=n/2^(2)
Длина массива после k-ой итерации: n/2^(k)
Т.к. длина массива после завершения поиска = 1, то
n/2^(k)=1
n=2^(k)
k=log n

O(n) = C1 + C2*log n + C3*log n + C4*log n + C5 = (C1+C2+C3)*log n +C1+C5=C*log n+ C15
O(C*log n+C15)= O(log n)
Бинарный рекурсивный поиск при рассмотрении развертывается в линейный, а значит имеет аналогичную сложность т.е. O(log n)

Т.к сложность линейного поиска больше, чем бинарного, то очевидно, что и время работы будет больше.

